# Object-Identification
Repository for my Object Identification software

Introduction:

This software is the result of experimentation with BoofCV. No actual product or application was made. The two major functions it has are ASCII conversion and object identification within an image. ASCII is a form of displaying images using only standard keyboard characters. There are two kinds of ASCII display: large and small scale. Large scale uses character density for shading different parts of the image. Small sclae uses the geometry of the characers to match details in the image. Small scale is much harder to do by code. My software can only convert into large scale ASCII. The Object Identification function is a lot more logically challenging. This function was developed with a specific goal in mind. Protein crystalographers line up crystals with an x-ray laser and shoot them to find out what the protein crystal structure is. Having to line the incredibly small crystals up with an incredibly small beam makes the process very long. A power camera is used to take a photo of these small crystals ahead of time. The image that this camera produces is the image I work with. The goal of this software is to use this image to locate the crystals on a dish, send the coordinates to a mobile laser, and have the laser line itself up. This way, in less than the time it takes to shoot one laser the manual way, 100+ cyrstals can be shot and recorded.

Summary of the ASCII function:

I developed the ASCII function as sort of practice to familiarize myself with BoofCV and computer vision in general. The software method is simple. Computers represent brightness with a number from 0 to 255. In this version of the software, I partition this range and simply assign characters to each sub range of values. Bright (255) would be represented by the " " character or the "." character. Darkness (0) would be represented by denser characters like "W" and "@". With this, I could switch "packs" by assigning different partitions to different characters. I played with things like inverse color packs, bright color packas, dakr color packs, binary color packs, and detailed color packs. I even made packs for art styles, although the computer couldn't automatically detect the art style and switch accordingly.

Summary of the Object Identification function:

The images produced by the camera are pretty low quality. The camera is imaging incredibly small crystals, therfore, any details in the background are also picked up. In this case, the background of the image is very fuzzy. In basic object identification they take the color difference between each pixel. Where the difference is high, you know there is a new object. Since the background is fuzzy, however, the differences in the background were also picked up leaving the new image with a lot of "noise". I developed a noise reducing algorithm that clears out less dense areas of the image. Actual object lines are always more dense than noise. Next, the computer had to identify which group of pixels is an individual crystals. My approach was to say that consecutive pixels make a crystal, but on the noice canceled difference array, each crystal was not necessarily composed of consecutive pixels. To solve this, I wrote a, image shrink method that condenses the image down so that small floating groups of pixels become connected to the contiguous pixels. Then using "flood find" (flooding an area and identifying that area as an object) I found every pixel of each crystal. By averaging the coordinates of these pixels, I located the center of each crystal. The final step was to plot them back onto the original image to see if my centers of masses lined up with actual crystals.

There are smaller auxilary classes that I didn't feel the need to include because of the simplicity of them.
